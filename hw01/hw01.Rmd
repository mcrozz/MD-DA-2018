---
title: 'Home work #1'
author: "Ivan Zarudny"
date: "September 26, 2018"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Работа с данными

### Загрузка данных

```{r}
data.df <- read.table("http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat", header = TRUE)
```

### Количество строк

```{r}
nrow(data.df)
```

### Количество столбцов

```{r}
ncol(data.df)
```

### Наименование столбцов

```{r}
colnames(data.df)
```

### Нахождение значения из 5 строки седьмого столбца

```{r}
data.df[5,7]
```

### Строка 2

```{r}
data.df[2,]
```

### Работа с ``head`` и ``tail``
>Объясните, что делает следующая строка кода ``names(data.df) <- c("year", "month", "day", seq(0,23))``. Воспользуйтесь функциями ``head`` и ``tail``, чтобы просмотреть таблицу. Что представляют собой последние 24 колонки?

Следующая строчка кода изменяет наименование столбцов.
```{r}
names(data.df) <- c("year", "month", "day", seq(0, 23))
```

```{r}
head(data.df)
```

```{r}
tail(data.df)
```

Последние 24 колонки представляют собой данные за 80-й год от 25-го по 30-е ноября. Все значения равны нулю, следовательно осадков не было.

### Работа с графиками
>Добавьте новую колонку с названием *daily*, в которую запишите сумму крайних правых 24 колонок. Постройте гистограмму по этой колонке. Какие выводы можно сделать?

Добавление новой колонки, которая является суммой крайних правых 24 колонок.
```{r}
last_column_index <- length(colnames(data.df))
start_sum_column <- last_column_index - 23

data.df["daily"] <- rowSums(data.df[start_sum_column:start_sum_column])
```

Построение гистограммы по колонке ``daily``
```{r}
hist(data.df$daily)
```

В данной гистограмме присутствуют отрицательные числа.

### Фильтрация данных
>Создайте новый датафрейм ``fixed.df`` в котром исправьте замеченную ошибку. Постройте новую гистограмму, поясните почему она более корректна.

```{r}
fixed.df <- data.df
fixed.df$daily <- abs(fixed.df$daily)
hist(fixed.df$daily)
```

Количество осадков не может быть отрицательна.

## Синтаксис и типизирование

### Тип данных
>Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна.

Создаём массив из строк:
```{r}
v <- c("4", "8", "15", "16", "23", "42")
```

Если рассматривать как численный ряд, то максимум находит не верно:
```{r}
max(v)
```

Так-же как и в прошлой строке - сортирует не верно:
```{r}
sort(v)
```

В данной строчке выдаёт ошибку, что входящий тип переменной не верен:
```{r eval=FALSE, include=TRUE}
sum(v)
```

Проблема заключается в неверном исходном типе данных:

```{r}
class(v)
```

Это можно исправить следующим преобразованием:
```{r}
v <- as.numeric(v)
class(v)
```

###
>Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочна.

```{r eval=FALSE, include=TRUE}
v2 <- c("5",7,12)
```

Невозможно производить сложение между типом ``character`` и ``numeric``:
```{r eval=FALSE, include=TRUE}
v2[2] + 2[3]
```

``data.frame`` преобразовал ``z1`` в тип ``factor``, хоть в примере и складываем две колонки, которые имеют тип данных ``numeric``, всё же сложение с ``z1`` будет выдавать ``NA`` значения с предупреждением.
```{r eval=FALSE, include=TRUE}
df3 <- data.frame(z1="5",z2=7,z3=12)
df3[1,2] + df3[1,3]
```

В то время как ``list`` ``z1`` воспринимает в прямом его виде - ``character``, список создаётся, сложение по ``z2`` с ``z4`` происходит успешно и правильно.
```{r eval=FALSE, include=TRUE}
l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]]
```

Если в прошлой строчке было сложение элементов 2-го с 4-м столбцов первой строки, то в данной строчке написнао сложение двух векторов (``list``), один - второй столбец, второй - четвёртый столбец. Поэтому данная строчка выдаёт ошибку.
```{r eval=FALSE, include=TRUE}
l4[2] + l4[4]
```

## Работа с функциями и операторами

### Функция ``seq()``
>Оператор двоеточие создаёт последовательность целых чисел по порядку. Этот оператор — частный случай функции ``seq()``, которую вы использовали раньше. Изучите эту функцию, вызвав команду ``?seq``.

Числа от 1 до 10000 с инкрементом 372:
```{r}
seq(1, 10000, by = 372)
```

Числа от 1 до 10000 длиной 50:
```{r}
seq(1, 10000, length.out = 50)
```


### Функция ``rep()``
>Функция ``rep()`` повторяет переданный вектор указанное число раз. Объясните разницу между ``rep(1:5,times=3)`` и ``rep(1:5, each=3)``

Повторение вектора ``[1, 2, 3, 4, 5]`` три раза друг за другом:
```{r}
rep(1:5, times = 3)
```

Дублирование элементов вектора ``[1, 2, 3, 4, 5]`` три раза:
```{r}
rep(1:5, each = 3)
```
