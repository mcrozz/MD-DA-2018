---
title: "Laboratory 2"
author: "Ivan Zarudny"
date: "September 30, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Исходные данные
>Установленная среда R включает в себя набор заранее сконфигурированных массивов данных.
В данной лабораторной требуется использовать одну из них — датафрейм из 93 машин-новинок 1993 года. Для того, чтобы загрузить данный датафрейм, необходимо выполнить следующие команды:

```{r}
library(MASS)
data(Cars93)
View(Cars93)
```

# Задание 1
## 1
>Выполните команду ``summary()`` на полном наборе данных. Можно ли по результату выполнения сказать сколько строк в датафрейме? Если да, напишите сколько. Если нет, то приведите другой способ.

```{r}
summary(Cars93)
```

Количество строк можно выявить из данного представления, но не в прямом виде. Можно получить значение строк при помощи функции `nrow(x)`: `r nrow(Cars93)`

## 2
>Найдите среднюю цену машин с задним приводом.

```{r}
mean(Cars93[Cars93[, "DriveTrain"] == "Rear", "Price"])
```

## 3
>Найдите минимальное число лошадиных сил автомобиля для 7 пассажиров. Для 6 пассажиров.

```{r}
min(Cars93[Cars93[, "Passengers"] == 7, "Horsepower"])
```

```{r}
min(Cars93[Cars93[, "Passengers"] == 6, "Horsepower"])
```

## 4
>Найдите машины с максимальным, минимальным и средним (медианой) расстоянием, которая машина может проехать по трассе. Вам понадобятся 2 колонки, чтобы рассчитать расстояние. Какие?

Понадобятся следующие колонки: `MPG.highway` и `Fuel.tank.capacity`. Добавим колонку `distance`, которая будет показывать какое расстояние машина может проехать на одном баке по трассе.

```{r}
Cars93.distance <- Cars93$MPG.highway * Cars93$Fuel.tank.capacity
```

```{r}
Cars93$Make[which(Cars93.distance == max(Cars93.distance))]
```

```{r}
Cars93$Make[which(Cars93.distance == min(Cars93.distance))]
```

```{r}
Cars93$Make[which(Cars93.distance == median(Cars93.distance))]
```

# Задание 2
>В самом начале занятий приводился пример с фабрикой и производством автомобилей. Ниже приведён пример кода, который старается оптимизировать выпуск продукции ориентируясь на доступные ресурсы.

## 1
>Выполните код и запустите эту функцию ``factory.run()``.

```{r}
factory.run <- function (o.cars=1, o.trucks=1) {
  factory <- matrix(c(40,1,60,3),nrow=2, dimnames=list(c("трудодни","сталь"),c("автомобили","грузовики")))
  warehouse <- c(1600,70) #Доступно материалов на складе
  names(warehouse) <- rownames(factory)
  reserve <- c(8,1)
  names(reserve) <- rownames(factory)
  output <- c(o.cars, o.trucks)
  names(output) <- colnames(factory)
  
  steps <- 0 # Счётчик числа шагов цикла
  repeat {
    steps <- steps + 1
    needed <- factory %*% output # Подсчитаем ресурсы, которые нам нужны для производства требуемого кол-ва машин
#    message(steps)
#    print(needed)
    # Если ресурсов достаточно и остаток меньше или равен резерву, то мы произвели максимум возможного.
    # Нужно прекращать
    if (all(needed <= warehouse) && all((warehouse - needed) <= reserve)) {
      break()
    }
    # Если заявка слишком большая и ресурсов недостаточно, уменьшим её на 10%
    if (all(needed > warehouse)) {
      output <- output * 0.9
      next()
    }
    # Если всё наоброт, то увеличим на 10%
    if (all(needed < warehouse)) {
      output <- output * 1.1
      next()
    }
    # Если мы потребили одного ресурса слишком много, а другого недостаточно,
    # то увеличим план на случайную величину
    output <- output * (1+runif(length(output),min=-0.1,max=0.1))
  }
  
  return(output)
}

result <- floor(factory.run())
```

## 2
>С каким входными значениями функция вызвана? Какой получился результат?

Функция вызвана со стандартными значениям `o.cars=1` и `o.trucks=1`, иными словами один автомобиль и один грузовик. При выполнении функция выводит номер шага цикла и количество затрачиваемых ресурсов, сама функция возвращает количество автомобилей и грузовиков, оптимальное количество.

Результат получился `r result['автомобили']` автомобилей и `r result['грузовики']` грузовиков.

## 3
>Повторите вызов 4 раза. Полученные ответы отличаются от полученных ранее? Если да, почему? Если нет, почему?

```{r}
run_1 <- factory.run()
run_2 <- factory.run()
run_3 <- factory.run()
run_4 <- factory.run()
all(run_1 == run_2, run_2 == run_3, run_3 == run_4)
```

Результаты будут отличаться, так как для оптимизации выпуска используются случайные величины.

## 4
>В приведённом коде, переменные _steps_ и _output_ находятся внутри алгоритма. Измените функцию так, чтобы она возвращала число шагов и произведённое количество машин.

```{r}
factory.run.new <- function (o.cars=1, o.trucks=1) {
  factory <- matrix(c(40,1,60,3),nrow=2, dimnames=list(c("трудодни","сталь"),c("автомобили","грузовики")))
  warehouse <- c(1600,70) #Доступно материалов на складе
  names(warehouse) <- rownames(factory)
  reserve <- c(8,1)
  names(reserve) <- rownames(factory)
  output <- c(o.cars, o.trucks)
  names(output) <- colnames(factory)
  
  steps <- 0 # Счётчик числа шагов цикла
  repeat {
    steps <- steps + 1
    needed <- factory %*% output # Подсчитаем ресурсы, которые нам нужны для производства требуемого кол-ва машин
    # Если ресурсов достаточно и остаток меньше или равен резерву, то мы произвели максимум возможного.
    # Нужно прекращать
    if (all(needed <= warehouse) && all((warehouse - needed) <= reserve)) {
      break()
    }
    # Если заявка слишком большая и ресурсов недостаточно, уменьшим её на 10%
    if (all(needed > warehouse)) {
      output <- output * 0.9
      next()
    }
    # Если всё наоброт, то увеличим на 10%
    if (all(needed < warehouse)) {
      output <- output * 1.1
      next()
    }
    # Если мы потребили одного ресурса слишком много, а другого недостаточно,
    # то увеличим план на случайную величину
    output <- output * (1+runif(length(output),min=-0.1,max=0.1))
  }
  
  result <- c(steps, needed, output[["автомобили"]])
  names(result) <- c("Количество шагов", "Трудодни", "Сталь", "Количество автомобилей")
  return(result)
}

factory.run.new()
```

## 5
>Установите план равный тридцати автомобилям и 20 грузовикам и выполните функцию.

```{r}
result <- floor(factory.run.new(o.cars = 30, o.trucks = 20))
```

>Какой получили результат? Каким получился итоговый запрос ресурсов (переменная _needed_). Как много итераций пришлось пройти, чтобы получить ответ (переменная _steps_)? 

В результате было выполнено `r result[1]` шагов, итоговый запрос ресуров получился `r result[2]` трудодней и `r result[3]` стали, оптимизация выполнена не успешно, сделано только `r result[4]` автомобилей.
